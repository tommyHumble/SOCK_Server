#asd


#!/usr/bin/python3
# -*- coding: utf-8 -*-

"""
Cервис валидации готовности инфраструктуры заказчика.
Данынй сервис работает на основе 'Клиент-сервер'. Он проверяет доступность портов между серверами,
формирует отчет и отправляет его в БД SQLite

Запуск сервиса в указанном режиме (client/server):

- client: val_Service.py cl serverList.json
    - cl - атрибут для запуска сервиса в клиентском режиме
    - serverList.json - файл содержащий необходимую ифнормацию о серверах и портах для проверки

- server: val_Service.py srv
    - srv - атрибут для запуска сервиса в серверном режиме
"""

__version__ = 1.0
__author__ = "slava.tomshin.95@mail.ru"


import socketserver
import json
import threading
import time
import socket
import logging
import sys
import uuid
import sqlite3


def get_ip():
    """
    Данная ф-ция позволяет определить ip адрес интерфейса,
    через который устройство устанавливает связь по сети Интернет.
    Доступ в сеть Интернет не обязателен.

    :return: ip address (type - str)
    """
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(('10.255.255.255', 1))
        IP = s.getsockname()[0]
    except:
        IP = '127.0.0.1'
    finally:
        s.close()
    return IP

# ip клиента/сервера
hostAddress = get_ip()

# Имя устройства
hostName = socket.gethostname()
hostName = str(hostName.strip())

# Словарь отчетов о состоянии серверов, которых мы опросили, составленные на стороне клиента
mainClientReports = {}

# Словарь отчетов о состоянии серверов, которых мы опросили, составленные на стороне сервера
mainServerReports = {}

# Словарь отчетов о состоянии серверов, которых мы опросили, составленные на основании 2-ух предыдущих отчетов
finalReports = {}

# Словарь состояния главного порта TCP 3242 на опрашиваемых серверах
serversStatusDic = {}

# Словарь состояния портов на сервере, которые он поднял для проверки, по запросу клиента
serverPortsStatusDic = {}

# Отчеты серверов, которые произвели валидацию в качестве клиента
finalServerReports = {}

# Словарь отчетов о состоянии серверов, которые будут отправлены клиенту на сравнение
serverPersonalReports = {}

# Словарь сокетов, которые были запущены на сервере для проверки
serveingPorts = {}

def form_report(cl, srv):
    """
    Данная ф-ция формирует итоговый отчет на основании двух отчетов -
    со стороны сервера и со стороны клиента.

    :param cl: Отчет со стороны клиента из mainClientReports
    :param srv: Отчет со стороны сервера из mainServertReports
    :return: итоговый отчет (type - dict)
    """
    report = {}
    report["client address"] = hostAddress
    report["client name"] = hostName
    report["server address"] = srv["server address"]
    report["server name"] = srv["server name"]
    report["respond time"] = cl["server respond time"]
    report["status"] = "OK"
    report["protocol"] = {}

    if srv["report"]["protocol"]["TCP"]:
        report["protocol"]["TCP"] = {}
        for port in srv["report"]["protocol"]["TCP"].keys():
            # Важно, что порт в отчете клиента указывается как int а в отчете с сервера указывается как str (из-за декодирования в json строку на стороне сервера)
            if srv["report"]["protocol"]["TCP"][port]["send"] == "OK" and cl["report"]["protocol"]["TCP"][int(port)]["send"] == "OK" and srv["report"]["protocol"]["TCP"][port]["recv"] == "OK" and cl["report"]["protocol"]["TCP"][int(port)]["recv"] == "OK":
                report["protocol"]["TCP"][port] = "OK"
            else:
                report["protocol"]["TCP"][port] = "NOT OK"

    if srv["report"]["protocol"]["UDP"]:
        report["protocol"]["UDP"] = {}
        for port in srv["report"]["protocol"]["UDP"].keys():
            if srv["report"]["protocol"]["UDP"][port]["send"] == "OK" and cl["report"]["protocol"]["UDP"][int(port)]["send"] == "OK" and srv["report"]["protocol"]["UDP"][port]["recv"] == "OK" and cl["report"]["protocol"]["UDP"][int(port)]["recv"] == "OK":
                report["protocol"]["UDP"][port] = "OK"
            else:
                report["protocol"]["UDP"][port] = "NOT OK"
    return report

def form_final_report(client_reports, server_reports):
    """
    Данная ф-ция формирует итоговый отчет о всей проделанной работе сервиса.

    :param client_reports: Итоговые отчеты клиента из finalReports
    :param server_reports: Итоговые отчеты серверов, о проделанной работе в качестве клиента из finalServerReports
    :return: Итоговый отчет (type - dict)
    """
    final_report = {"problems": {}, f"{hostAddress} - MCL": {}}
    for id, report in client_reports.items():
        final_report[report["client address"] + " - MCL"][report["server address"]] = {
            "server name": report["server name"],
            "respond time": report["respond time"],
            "report": report["protocol"]
        }
        for protocol, ports in report["protocol"].items():
            for port, status in ports.items():
                if status == "NOT OK":
                    if report["client address"] not in final_report["problems"].keys():
                        final_report["problems"][report["client address"]] = {}
                    if report["server address"] not in final_report["problems"][report["client address"]].keys():
                        final_report["problems"][report["client address"]][report["server address"]] = {}
                    if protocol not in final_report["problems"][report["client address"]][report["server address"]].keys():
                        final_report["problems"][report["client address"]][report["server address"]][protocol] = {}
                    final_report["problems"][report["client address"]][report["server address"]][protocol][port] = status
    if not server_reports:
        return final_report

    for id1, id2_dic in server_reports.items():
        for id2, report in id2_dic.items():
            if report["client address"] not in final_report.keys():
                final_report[report["client address"]] = {}
            if report["status"] == "OK":
                final_report[report["client address"]][report["server address"]] = {
                    "server name": report["server name"],
                    "respond time": report["respond time"],
                    "report": report["protocol"]
                }
                for protocol, ports in report["protocol"].items():
                    for port, status in ports.items():
                        if status == "NOT OK":
                            if report["client address"] not in final_report["problems"].keys():
                                final_report["problems"][report["client address"]] = {}
                            if report["server address"] not in final_report["problems"][report["client address"]].keys():
                                final_report["problems"][report["client address"]][report["server address"]] = {}
                            if protocol not in final_report["problems"][report["client address"]][report["server address"]].keys():
                                final_report["problems"][report["client address"]][report["server address"]][protocol] = {}
                            final_report["problems"][report["client address"]][report["server address"]][protocol][port] = status
            elif report["status"] == "NOT OK":
                final_report[report["client address"]] = {
                    "problem": report["problem"],
                    "report": report["report"]
                }
                final_report["problems"][report["client address"]] = {
                    "problem": report["problem"],
                    "report": {}
                }
                for ip, value in report["report"].items():
                        if ip != "status" and value == "DOWN":
                            final_report["problems"][report["client address"]]["report"][ip] = value
    return final_report

def config_check(file_name):
    try:
        problems_dic = {}
        num = 1
        with open(file_name, 'r') as f_r:
            serversList = json.load(f_r)
            for server in serversList:
                if "ip" not in server.keys():
                    problems_dic[f"{num} server"] = "ip field"
                    num += 1
                    continue
                else:
                    if type(server["ip"]) != str:
                        problems_dic[f"{num} server"] = "ip type"
                        continue
                if "ports" not in server.keys():
                    problems_dic[f"{num} server"] = "ports field"
                    num += 1
                    continue
                else:
                    if type(server["ports"]) != dict:
                        problems_dic[f"{num} server"] = "ports type"
                        num += 1
                        continue
                    else:
                        if len(server["ports"]) > 2:
                            problems_dic[f"{num} server"] = "ports protocols more then 2"
                            num += 1
                            continue
                for prot, ports in server["ports"].items():
                    if prot != "TCP" and prot != "UDP":
                        problems_dic[f"{num} server"] = f"{prot} is not available key"
                        break
                    else:
                        if type(server["ports"][prot]) != list:
                            problems_dic[f"{num} server"] = f"all ports must be written in list format"
                            break
                        else:
                            for port in ports:
                                if type(port) != int:
                                    problems_dic[f"{num} server"] = f"{port} must be integer"
                                    break
                num += 1
            if problems_dic:
                return (1, problems_dic)
            else:
                return (0, serversList)
    except FileNotFoundError:
        print("File wasn\'t found. Check the name of the configuration file.")
        return (2, problems_dic)
    except json.JSONDecodeError:
        print("File is not a valid JSON document. Check the structure of the configuration file.")
        return (3, problems_dic)
    except:
        print("Unknown error was raised while validation of the configuration file.")
        return (4, problems_dic)

# Настройка логирования на стороне сервера
loggerS = logging.getLogger("Server_Side")
loggerS.setLevel(logging.DEBUG)
fileHandler = logging.FileHandler("server_logs.log", mode="w")
fileFormatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
fileHandler.setFormatter(fileFormatter)
loggerS.addHandler(fileHandler)

# Настройка логирования на стороне клиента
loggerCl = logging.getLogger("Client_Side")
loggerCl.setLevel(logging.DEBUG)
fileHandler = logging.FileHandler("client_logs.log", mode="w")
fileFormatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
fileHandler.setFormatter(fileFormatter)
loggerCl.addHandler(fileHandler)


class clientThread(threading.Thread):
    """
    Экземпляром данного класса является поток, который устанавливает
    соединение клиента с сервером через порт TCP 3242
    """
    def __init__(self, server_ip, server_port, port_checkList, server_checkList, id_statusDic, *args):
        """
        При создании экземпляра класса необходимо передать следующие параметры:

        :param server_ip: ip адрес сервера, с которым собираемся установить соединение
        :param server_port: порт с которым мы собираемся установить соеинение на сервером
        :param port_checkList: список портов, которые мы передадим серверу, и которые сервер должен будет активировать
        :param server_checkList: список всех серверов, которые необходимо проверить
        :param id_statusDic: уникальный иднетификатор, позволяющий инициализировать данное соединение (сессию)
        :param args: список дополнительных аргументов. Не пуст, когда создается поток на главном клиенте
        """
        self.server_ip = server_ip
        self.server_main_port = server_port
        self.port_checkList = port_checkList
        self.server_checkList = server_checkList
        self.adds = args
        self.conn_id = str(uuid.uuid4())
        self.id_statusDic = id_statusDic
        threading.Thread.__init__(self)

    def run(self):
        """
        Выполнение соединения с сервером TCP 3242 и дальнейшая отправка спец. сообщений

        Типы сообщений:
        - mainRequest - сообщение предназначенное для проверки установленного соединения с сервером через порт TCP 3242
        - portList - список портов которые серверу необходимо поднять для проверки
        - reportRequest - клиент запрашивает отчет, составленный на стороне сервера о произведенной проверки во время установленной сессии
        - serverReportRequest - главный клиент запрашивает отчеты серверов, которые отработали в качестве клиентов
        """
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            try:
                sock.settimeout(4)
                flag = "main connection"
                sock.connect((self.server_ip, self.server_main_port))
                loggerCl.debug(f"Connection with {self.server_ip} TCP {self.server_main_port} was settled successfully")
                mainClientReports[self.conn_id] = {
                          "type": "clientReport",
                          "client address": hostAddress,
                          "client name": hostName,
                          "server address": self.server_ip,
                          "connection id": self.conn_id,
                          "server respond time": None,
                          "report": {
                              "protocol": {
                                  "TCP": {},
                                  "UDP": {}
                              }
                          }
                        }

                flag = "sendall mainRequest"
                mainRequest = {
                  "type": "mainRequest",
                  "command": "mainCheck",
                  "connection id": self.conn_id,
                  "message": f"PORT {self.server_main_port} STATUS",
                  "client": hostAddress
                }
                mainRequest = json.dumps(mainRequest)
                sock.sendall(bytes(mainRequest, encoding='utf-8'))
                sendallTime = time.time()
                loggerCl.debug(f"mainRequest to {self.server_ip} TCP {self.server_main_port} was sent successfully: {mainRequest}")

                flag = "recv mainRespond"
                rcv = sock.recv(4096)
                recvTime = time.time()
                loggerCl.debug(f"Message from {self.server_ip} TCP {self.server_main_port} was received successfully")
                msg = rcv.decode()
                loggerCl.debug(f"Message from {self.server_ip} TCP {self.server_main_port} was decoded successfully")
                pyMsg = json.loads(msg)
                loggerCl.debug(f"Message from {self.server_ip} TCP {self.server_main_port} was decoded in python object successfully")
                if pyMsg["type"] == "mainRespond":
                    sock.settimeout(4)
                    serversStatusDic[self.id_statusDic][self.server_ip] = "UP"
                    loggerCl.debug(f"mainRespond from {self.server_ip} TCP {self.server_main_port} was received successfully: {pyMsg}")
                    mainClientReports[self.conn_id]["server respond time"] = recvTime - sendallTime
                else:
                    serversStatusDic[self.id_statusDic][self.server_ip] = "DOWN"
                    loggerCl.error(f"Unknown message from {self.server_ip} TCP {self.server_main_port} was received successfully. Expected mainRespond.")
                    serversStatusDic[self.id_statusDic]["status"] = "NOT OK"
                    return

                while True:
                    if len(self.server_checkList)+1 == len(serversStatusDic[self.id_statusDic]):
                        if serversStatusDic[self.id_statusDic]["status"] == "NOT OK":
                            finalReports[self.conn_id] = {
                                "client address": hostAddress,
                                "client name": hostName,
                                "status": "NOT OK",
                                "problem": "NO ACCESS TO ALL SERVERS",
                                "report": serversStatusDic[self.id_statusDic]
                            }
                            del mainClientReports[self.conn_id]
                            return
                        else:
                            break

                flag = "sendall portList"
                portList = {
                  "type": "portList",
                  "command": "check",
                  "client address": hostAddress,
                  "client name": hostName,
                  "connection id": self.conn_id,
                  "ports": self.port_checkList,
                }
                portList = json.dumps(portList)
                loggerCl.debug(f"portList for {self.server_ip} TCP {self.server_main_port} was decoded into json format successfully")
                sock.sendall(bytes(portList, encoding="utf-8"))
                loggerCl.debug(f"portList for {self.server_ip} TCP {self.server_main_port} was sent successfully: {portList}")

                flag = "recv portListRespond"
                rcv = sock.recv(4096)
                loggerCl.debug(f"Message from {self.server_ip} TCP {self.server_main_port} was received successfully")
                msg = rcv.decode()
                loggerCl.debug(f"Message from {self.server_ip} TCP {self.server_main_port} was decoded successfully")
                pyMsg = json.loads(msg)
                loggerCl.debug(f"Message from {self.server_ip} TCP {self.server_main_port} was decoded in python object successfully")
                if pyMsg["type"] == "portListRespond":
                    loggerCl.debug(f"portListRespond from {self.server_ip} TCP {self.server_main_port} was received successfully: {pyMsg}")
                else:
                    loggerCl.error(f"Unknown message from {self.server_ip} TCP {self.server_main_port} was recieved. Expected portListRespond")
                    return

                flag = "recv activePortListResp"
                rcv = sock.recv(8192)
                loggerCl.debug(f"Message from {self.server_ip} TCP {self.server_main_port} was received successfully")
                msg = rcv.decode()
                loggerCl.debug(f"Message from {self.server_ip} TCP {self.server_main_port} was decoded successfully")
                pyMsg = json.loads(msg)
                loggerCl.debug(f"Message from {self.server_ip} TCP {self.server_main_port} was decoded in python object successfully")
                if pyMsg["type"] == "activePortListRespond":
                    loggerCl.debug(f"activePortListRespond from {self.server_ip} TCP {self.server_main_port} was received successfully: {pyMsg}")
                    if pyMsg["message"] == "NOT OK":
                        serverPortsStatusDic[self.id_statusDic]["status"] = "NOT OK"
                        serverPortsStatusDic[self.id_statusDic][self.server_ip] = pyMsg["report"]
                        finalReports[self.conn_id] = {
                                "client address": hostAddress,
                                "client name": hostName,
                                "server address": self.server_ip,
                                "server name": pyMsg["server name"],
                                "respond time": recvTime - sendallTime,
                                "status": "NOT OK",
                                "problem": "NOT ALL PORTS ON SERVER WERE ACTIVATED",
                                "report": serverPortsStatusDic[self.id_statusDic]
                            }
                        del mainClientReports[self.conn_id]
                        loggerCl.error(f"Not all ports on {self.server_ip} were activated successfully: {serverPortsStatusDic[self.id_statusDic]}")
                        return
                    else:
                        serverPortsStatusDic[self.id_statusDic][self.server_ip] = pyMsg["report"]
                        loggerCl.info(f"All ports on {self.server_ip} were activated successfully: {serverPortsStatusDic[self.id_statusDic]}")
                else:
                    loggerCl.error(f"Unknown message from {self.server_ip} TCP {self.server_main_port} was received. Expected activePortListRespond")
                    return

                while True:
                    if len(self.server_checkList)+1 == len(serverPortsStatusDic[self.id_statusDic]):
                        if serverPortsStatusDic[self.id_statusDic]["status"] == "OK":
                            loggerCl.info(f"All servers activated all ports: {serverPortsStatusDic[self.id_statusDic]}")
                            break
                        else:
                            loggerCl.error(f"Not all servers activated all ports: {serverPortsStatusDic[self.id_statusDic]}")
                            return

                threadList = []
                for protocol, ports in self.port_checkList.items():
                    for port in ports:
                        portThread = portCheckThread(self.server_ip, port, protocol, self.conn_id)
                        threadList.append(portThread)
                        portThread.start()
                for thread in threadList:
                    if thread.isAlive():
                        thread.join()

                flag = "sendall reportRequest"
                reportRequest = {
                  "type": "reportRequest",
                  "command": "check",
                  "client address": hostAddress,
                  "client name": hostName,
                  "server address": self.server_ip,
                  "connection id": self.conn_id,
                  "message": "NEED REPORT"
                }
                reportRequest = json.dumps(reportRequest)
                loggerCl.debug(f"reportRequest for {self.server_ip} TCP {self.server_main_port} was decoded in json string successfully")
                sock.sendall(bytes(reportRequest, encoding="utf-8"))
                loggerCl.debug(f"reportRequest for {self.server_ip} TCP {self.server_main_port} was sent successfully: {reportRequest}")

                flag = "recv reportRespond"
                # rcv = sock.recv(15000)
                rcv = b""
                while True:
                    rcv_part = sock.recv(512)
                    rcv += rcv_part
                    if len(rcv_part) < 512:
                        break
                loggerCl.debug(f"Message from {self.server_ip} TCP {self.server_main_port} was recieved successfully")
                msg = rcv.decode()
                loggerCl.debug(f"Message from {self.server_ip} TCP {self.server_main_port} was decoded successfully")
                pyMsg = json.loads(msg)
                loggerCl.debug(f"Message from {self.server_ip} TCP {self.server_main_port} was decoded in python obj successfully")
                if pyMsg["type"] == "reportRespond":
                    loggerCl.debug(f"reportRespond from {self.server_ip} TCP {self.server_main_port} was received successfully: {pyMsg}")
                    mainServerReports[self.conn_id] = pyMsg
                else:
                    loggerCl.error(f"Unknown message from {self.server_ip} TCP {self.server_main_port} was received. Expected reportRespond")
                    return

                if self.adds:
                    sock.settimeout(6)
                    serverList = []
                    for server in self.server_checkList:
                        if server["ip"] != self.server_ip:
                            serverList.append(server)
                    if not serverList:
                        # Когда сервер в списке всего один, то ServerReportRespond не нужен
                        return
                    flag = "sendall serverReportRequest"
                    serverReportRequest = {
                      "type": "serverReportRequest",
                      "command": "check",
                      "client address": hostAddress,
                      "client name": hostName,
                      "connection id": self.conn_id,
                      "message": "NEED SERVER REPORT",
                      "server list": serverList
                    }
                    serverReportRequest = json.dumps(serverReportRequest)
                    loggerCl.debug(f"serverReportRequest for {self.server_ip} TCP {self.server_main_port} was decoded in json string successfully")
                    sock.sendall(bytes(serverReportRequest, encoding="utf-8"))
                    loggerCl.debug(f"serverReportRequest for {self.server_ip} TCP {self.server_main_port} was sent successfully: {serverReportRequest}")

                    flag = "recv serverReportRespond"
                    # rcv = sock.recv(16284)
                    rcv = b""
                    while True:
                        rcv_part = sock.recv(512)
                        rcv += rcv_part
                        if len(rcv_part) < 512:
                            break
                    loggerCl.debug(f"Message from {self.server_ip} TCP {self.server_main_port} was received successfully")
                    msg = rcv.decode()
                    loggerCl.debug(f"Message from {self.server_ip} TCP {self.server_main_port} was decoded successfully")
                    pyMsg = json.loads(msg)
                    loggerCl.debug(f"Message from {self.server_ip} TCP {self.server_main_port} was decoded in python obj successfully")
                    if pyMsg["type"] == "serverReportRespond":
                        loggerCl.debug(f"serverReportRespond from {self.server_ip} TCP {self.server_main_port} was received successfully: {pyMsg}")
                        finalServerReports[self.conn_id] = pyMsg["report"]
                    else:
                        loggerCl.error(f"Unknown message from {self.server_ip} TCP {self.server_main_port} was received. Expected reportRespond")
                        return

            except (ConnectionError, socket.timeout, OSError):
                if flag == "main connection":
                    loggerCl.error(f"Connection with {self.server_ip} TCP {self.server_main_port} wasn\'t settled")
                    serversStatusDic[self.id_statusDic]["status"] = "NOT OK"
                    serversStatusDic[self.id_statusDic][self.server_ip] = "DOWN"
                    if len(self.server_checkList) == 1:
                        finalReports[self.conn_id] = {
                                "client address": hostAddress,
                                "client name": hostName,
                                "status": "NOT OK",
                                "problem": "NO ACCESS TO ALL SERVERS",
                                "report": serversStatusDic[self.id_statusDic]
                            }
                else:
                    loggerCl.error(f"Timeout/Connection problems with {self.server_ip} TCP {self.server_main_port} while {flag} operation")
                return

            except json.JSONDecodeError:
                loggerCl.error(f"While {flag}, message {self.server_ip} TCP {self.server_main_port} wasn\'t decoded in json/python successfully: {msg}")
                return

            except UnicodeDecodeError:
                loggerCl.error(f"While {flag}, message {self.server_ip} TCP {self.server_main_port} wasn\'t decoded successfully")
                return

            except InterruptedError:
                loggerCl.error(f"{flag} operations with {self.server_ip} TCP {self.server_main_port} was interrupted")
                return



class portCheckThread(threading.Thread):
    """
    Экземпляром данного класса является поток, который устанавливает
    соединение клиента с портом на сервере, предназначенного для проверки,
    при помощи спец сообщений

    Тип сообщений:
    - simpleRequest - сообщение предназначенное для проверки доступа к порту на сервере
    """
    def __init__(self, server_ip, server_port, protocol, connection_id):
        """
        При создании экземпляра класса необходимо передать следующие параметры:

        :param server_ip: ip адрес сервера, с которым собираемся установить соединение
        :param server_port: порт с которым мы собираемся установить соеинение на сервером
        :param protocol: протокол по которому будет устанавилваться соединение с сервером (TCP или UDP)
        :param connection_id: уникальный иднетификатор, инициализирующий сессию внутри которой происходит проверка данного порта
        """
        self.server_ip = server_ip
        self.server_port = server_port
        self.protocol = protocol
        self.conn_id = connection_id
        threading.Thread.__init__(self)

    def run(self):
        """
        Метод запускает поток, который, в зависимости от переданных параметров, устанавливает
        соединение с соектом на сервере и производит обменн служебными сообщениями
        """
        if self.protocol == "TCP":
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as prtSock:
                try:
                    prtSock.settimeout(2)
                    flag = "TCP port connection"
                    prtSock.connect((self.server_ip, self.server_port))
                    loggerCl.debug(f"Connection with {self.server_ip} TCP {self.server_port} was settled")
                    mainClientReports[self.conn_id]["report"]["protocol"]["TCP"][self.server_port] = {"connection": "OK", "send": "NOT OK", "recv": "NOT OK"}

                    flag = "sendall simpleRequest"
                    simpleRequest = {
                      "type": "simpleRequest",
                      "command": "check",
                      "client address": hostAddress,
                      "client name": hostName,
                      "connection id": self.conn_id,
                      "message": "PORT STATUS",
                      "protocol": self.protocol,
                      "port": self.server_port
                    }
                    simpleRequest = json.dumps(simpleRequest)
                    loggerCl.debug(f"simpleRequest for {self.server_ip} TCP {self.server_port} was decoded in json string successfully")
                    prtSock.sendall(bytes(simpleRequest, encoding='utf-8'))
                    loggerCl.debug(f"simpleRequest for {self.server_ip} TCP {self.server_port} was sent successfully: {simpleRequest}")
                    mainClientReports[self.conn_id]["report"]["protocol"]["TCP"][self.server_port]["send"] = "OK"

                    flag = "recv simpleRespond"
                    rcv = prtSock.recv(4096)
                    loggerCl.debug(f"Message from {self.server_ip} TCP {self.server_port} was received successfully")
                    mainClientReports[self.conn_id]["report"]["protocol"]["TCP"][self.server_port]["recv"] = "OK"
                    msg = rcv.decode()
                    loggerCl.debug(f"Message from {self.server_ip} TCP {self.server_port} was decoded successfully")
                    pyMsg = json.loads(msg)
                    loggerCl.debug(f"Message from {self.server_ip} TCP {self.server_port} was decoded in python object successfully")
                    if pyMsg["type"] == "simpleRespond":
                        loggerCl.debug(f"simpleRespond from {self.server_ip} TCP {self.server_port} was received successfully: {pyMsg}")
                    else:
                        loggerCl.error(f"Unknown message from {self.server_ip} TCP {self.server_port} was received. Expected simpleRespond")

                except (ConnectionError, socket.timeout):
                    loggerCl.error(f"Timeout/Connection problems with {self.server_ip} TCP {self.server_port} while {flag} operation")
                    if flag == "TCP port connection":
                        mainClientReports[self.conn_id]["report"]["protocol"]["TCP"][self.server_port] = {"connection": "NOT OK", "sendall": "NOT OK", "recv": "NOT OK"}
                        return

                except json.JSONDecodeError:
                    loggerCl.error(f"While {flag} message {self.server_ip} TCP {self.server_port} wasn\'t decoded in json/python successfully: {msg}")
                    return

                except InterruptedError:
                    loggerCl.error(f"{flag} operations with {self.server_ip} TCP {self.server_port} was interrupted")
                    return


        elif self.protocol == "UDP":
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as prtSock:
                try:
                    prtSock.settimeout(2)
                    flag = "sendto simpleRequest"
                    mainClientReports[self.conn_id]["report"]["protocol"]["UDP"][self.server_port] = {"send": "NOT OK", "recv": "NOT OK"}
                    simpleRequest = {
                      "type": "simpleRequest",
                      "command": "check",
                      "client address": hostAddress,
                      "client name": hostName,
                      "connection id": self.conn_id,
                      "message": "PORT STATUS",
                      "protocol": self.protocol,
                      "port": self.server_port
                    }
                    simpleRequest = json.dumps(simpleRequest)
                    loggerCl.debug(f"simpleRequest for {self.server_ip} UDP {self.server_port} was decoded in json string successfully")
                    prtSock.sendto(bytes(simpleRequest, encoding="utf-8"), (self.server_ip, self.server_port))
                    loggerCl.debug(f"simpleRequest for {self.server_ip} UDP {self.server_port} was sent successfully: {simpleRequest}")
                    mainClientReports[self.conn_id]["report"]["protocol"]["UDP"][self.server_port]["send"] = "OK"

                    flag = "recv simpleRespond"
                    rcv = prtSock.recv(4096)
                    loggerCl.debug(f"Message from {self.server_ip} UDP {self.server_port} was received successfully")
                    mainClientReports[self.conn_id]["report"]["protocol"]["UDP"][self.server_port]["recv"] = "OK"
                    msg = rcv.decode()
                    loggerCl.debug(f"Message from {self.server_ip} UDP {self.server_port} was decoded successfully")
                    pyMsg = json.loads(msg)
                    loggerCl.debug(f"Message from {self.server_ip} UDP {self.server_port} was decoded in python object successfully")
                    if pyMsg["type"] == "simpleRespond":
                        loggerCl.debug(f"simpleRespond from {self.server_ip} UDP {self.server_port} was received successfully: {pyMsg}")
                    else:
                        loggerCl.error(f"Unknown message from {self.server_ip} UDP {self.server_port} was received. Expected simpleRespond")

                except socket.timeout:
                    loggerCl.error(f"Timeout error with {self.server_ip} UDP {self.server_port} while {flag} operation")

                except json.JSONDecodeError:
                    loggerCl.error(f"While {flag} message {self.server_ip} UDP {self.server_port} wasn\'t decoded in json/python successfully: {msg}")

                except InterruptedError:
                    loggerCl.error(f"{flag} operations with {self.server_ip} UDP {self.server_port} was interrupted")


class mainServerThread(threading.Thread):
    """
    Экземпляром класса является поток, запускающий на стороне сервера сокет-сервер прослушивающий порт TCP 3242,
    который, в зависимости от переданных ему со стороны клиента спец. сообщений, выполняет различные ф-ции
    """
    def __init__(self, addr, port):
        """
        При создании экземпляра класса необходимо передать следующие параметры:

        :param addr: ip адресс сервера, на котором запускаете сокет-сервер
        :param port: порт сервера, на котором запускаете сокет-сервер
        """
        self.addr = addr
        self.port = port
        threading.Thread.__init__(self)
        try:
            self.server = myTCPServer((self.addr, self.port), mainPortTCPRequestHandler)
            loggerS.debug(f"{self.addr} 'TCP' {self.port} SocketServer was created")
        except:
            loggerS.error(f"{self.addr} 'TCP' {self.port} SocketServer wasn\'t created")

    def run(self):
        """
        Метод запускает сокет-сервер в режиме serve_forever
        """
        try:
            self.server.serve_forever()
        except:
            loggerS.error(f"SocketServer on port {self.port} serve_forever error ")

    def stop_server(self):
        """
        Метод останавливает и закрывает сокет-сервер
        """
        try:
            self.server.shutdown()
            self.server.server_close()
            loggerS.debug(f"{self.addr} 'TCP' {self.port} server was shutdown")
        except:
            loggerS.error(f"{self.addr} 'TCP' {self.port} server couldn\'t be closed correctly")

class myTCPServer(socketserver.ThreadingMixIn, socketserver.TCPServer):
    """
    Экземпляром данного класса является TCP сокет-сервер на основе socketserver.TCPServer,
    а также socketserver.ThreadingMixIn для обеспеченияя многопоточной обработки соединений с клиентами
    """
    pass

class myUDPServer(socketserver.ThreadingMixIn, socketserver.UDPServer):
    """
    Экземпляром данного класса является UDP сокет-сервер на основе socketserver.UDPServer,
    а также socketserver.ThreadingMixIn для обеспеченияя многопоточной обработки сообщений от клиентов
    """
    pass

class mainPortTCPRequestHandler(socketserver.StreamRequestHandler):
    """
    Экземпляром данного класса является handler сокет-сервера, который выполняет обработку соединений
    установленных с клиентом через порт TCP 3242
    """
    def handle(self):
        """
        Метод обрабатывающий спец. сообщения переданные клиентом и в зависимости от типа сообщения
        выполняет ряд установленных операций.

        Типы сообщений:
        - mainRespond - ответ клиенту на mainRequest, подтверждающий установку соединения по порту TCP 3242
        - portListRespond - ответ клиенту на portList, подтверждающий получение списка портов, которые необходимо проверить
        - activePortListRespond - ответ клиенту, в котором сервер подтверждает поднятие всех портов, или уведомляет об ошибках на портах
        - reportRespond - отчет составленный на стороне сервера о проведенной тестировки портов
        - serverReportRespond - отчет составленный на стороне сервера, который выступил в роли клиента и произвел проверку доступа сервера к другим серверам
        """
        client_ip = self.client_address[0]
        local_port = self.request.getsockname()[1]
        loggerS.debug(f"Connection on TCP {local_port} with {client_ip} was settled")
        print(time.time(), f"Connection on TCP {local_port} with {client_ip} was settled")
        while True:
            try:
                flag = "main TCP port recv"
                # rcv = self.request.recv(4096)
                rcv = b""
                while True:
                    rcv_part = self.request.recv(4096)
                    rcv += rcv_part
                    if len(rcv_part) < 4096:
                        break
                if not rcv:
                        loggerS.debug(f"TCP connection on {local_port} with {client_ip} was completed")
                        print(f"TCP connection on {local_port} with {client_ip} was completed")
                        break
                loggerS.debug(f"Message from {client_ip} was received on main TCP {local_port} successfully")
                msg = rcv.decode()
                loggerS.debug(f"Message from {client_ip} on main TCP {local_port} was decoded successfully")
                pyMsg = json.loads(msg)
                loggerS.debug(f"Message from {client_ip} on main TCP {local_port} was decoded in python object successfully")

                if pyMsg["type"] == "mainRequest":
                    loggerS.debug(f"mainRequest was received from {client_ip} on main TCP {local_port} successfully: {pyMsg}")
                    conn_id = pyMsg["connection id"]
                    flag = "sendall mainRespond"
                    mainRespond = {
                      "type": "mainRespond",
                      "command": "mainCheck",
                      "server address": hostAddress,
                      "server name": hostName,
                      "connection id": conn_id,
                      "message": "3242 IS UP",
                    }
                    mainRespond = json.dumps(mainRespond)
                    loggerS.debug(f"mainRespond for {client_ip} TCP {local_port} was decoded into json string successfully")
                    self.request.sendall(bytes(mainRespond, encoding='utf-8'))
                    loggerS.debug(f"mainRespond was sent to {client_ip} from main TCP {local_port} successfully: {mainRespond}")
                    continue

                elif pyMsg["type"] == "reportRequest":
                    time.sleep(0.3)
                    loggerS.debug(f"reportRequest was received from {client_ip} on main TCP {local_port} successfully: {pyMsg}")
                    flag = "sendall reportRespond"
                    reportRespond = json.dumps(serverPersonalReports[conn_id])
                    loggerS.debug(f"reportRespond for {client_ip} TCP {local_port} was decoded into json string successfully")
                    self.request.sendall(bytes(reportRespond, encoding='utf-8'))
                    loggerS.debug(f"reportRespond was sent to {client_ip} from main TCP {local_port} successfully: {reportRespond}")
                    continue

                elif pyMsg["type"] == "serverReportRequest":
                    loggerS.debug(f"serverReportRequest was received from {client_ip} on main TCP {local_port} successfully: {pyMsg}")
                    checkList = []
                    idList = []
                    id_statusDic = str(uuid.uuid4())
                    serversStatusDic[id_statusDic] = {"status": "OK"}
                    serverPortsStatusDic[id_statusDic] = {"status": "OK"}
                    for server in pyMsg["server list"]:
                        thread = clientThread(server["ip"], local_port, server["ports"], pyMsg["server list"], id_statusDic)
                        idList.append(thread.conn_id)
                        checkList.append(thread)
                        thread.start()
                    for server in checkList:
                        if server.isAlive():
                            server.join()
                    del serversStatusDic[id_statusDic]
                    del serverPortsStatusDic[id_statusDic]
                    for id in idList:
                        if id in mainServerReports.keys():
                            finalReports[id] = form_report(mainClientReports[id], mainServerReports[id])
                            del mainServerReports[id]
                        if id in mainClientReports.keys():
                            del mainClientReports[id]

                    mainfinalReports = {}
                    for id in idList:
                        if id in finalReports.keys():
                            mainfinalReports[id] = finalReports[id]
                    flag = "sendall serverReportRespond"
                    serverReportRespond = {
                      "type": "serverReportRespond",
                      "command": "mainCheck",
                      "server address": hostAddress,
                      "server name": hostName,
                      "connection id": conn_id,
                      "report": mainfinalReports
                    }
                    serverReportRespond = json.dumps(serverReportRespond)
                    loggerS.debug(f"serverReportRespond for {client_ip} TCP {local_port} was decoded into json string successfully")
                    self.request.sendall(bytes(serverReportRespond, encoding='utf-8'))
                    loggerS.debug(f"serverReportRespond was sent to {client_ip} from main TCP {local_port} successfully: {serverReportRespond}")
                    for id in idList:
                        if id in finalReports.keys():
                            del finalReports[id]
                    continue

                elif pyMsg["type"] == "portList":
                    loggerS.debug(f"portList was received from {client_ip} main TCP {local_port} successfully: {pyMsg}")
                    flag = "sendall portListResp"
                    portListRespond = {
                      "type": "portListRespond",
                      "command": "mainCheck",
                      "server address": hostAddress,
                      "server name": hostName,
                      "connection id": conn_id,
                      "message": "OK"
                    }
                    portListRespond = json.dumps(portListRespond)
                    self.request.sendall(bytes(portListRespond, encoding='utf-8'))
                    loggerS.debug(f"portListRespond was sent to {self.client_address[0]} successfully: {portListRespond}")
                    serverPersonalReports[conn_id] = {
                      "type": "reportRespond",
                      "command": "mainCheck",
                      "server address": hostAddress,
                      "server name": hostName,
                      "connection id": conn_id,
                      "message": "REPORT",
                      "report": {
                          "protocol": {
                              "TCP": {},
                              "UDP": {}
                          }
                      }
                    }
                else:
                    loggerS.error(f"Unknown message was received from {client_ip}. Connection on TCP {local_port} was stopped.")
                    break

                flag = "sendall activePortList"
                time.sleep(0.3)
                activePortListRespond = {
                  "type": "activePortListRespond",
                  "command": "mainCheck",
                  "server address": hostAddress,
                  "server name": hostName,
                  "connection id": conn_id,
                  "message": "OK",
                  "report": {
                      "UDP": {},
                      "TCP": {}
                  }
                }
                for protocol, ports in pyMsg["ports"].items():
                    for port in ports:
                        if (port, protocol) in serveingPorts.keys():
                            if serveingPorts[port, protocol].isAlive():
                                loggerS.debug(f"{protocol} server on {port} is already launched")
                                serverPersonalReports[conn_id]["report"]["protocol"][protocol][port] = {"sockServ creation": "OK", "serve_forever": "OK", "recv": "NOT OK", "send": "NOT OK"}
                                activePortListRespond["report"][protocol][port] = "OK"
                            else:
                                serverPersonalReports[conn_id]["report"]["protocol"][protocol][port] = {"sockServ creation": "OK", "serve_forever": "NOT OK", "recv": "NOT OK", "send": "NOT OK"}
                                try:
                                    serveingPorts[port, protocol].start()
                                    loggerS.debug(f"{protocol} {port} was activated again")
                                    serverPersonalReports[conn_id]["report"]["protocol"][protocol][port]["serve_forever"] =  "OK"
                                    activePortListRespond["report"][protocol][port] = "OK"
                                except:
                                    activePortListRespond["message"] = "NOT OK"
                                    activePortListRespond["report"][protocol][port] = "NOT OK"
                                    loggerS.error(f"Didn\'t manage to reactivate server on {protocol} {port}")
                                    serveingPorts[port, protocol].stop_server()
                                    del serveingPorts[port, protocol]
                        else:
                            thread = portThread(port, protocol, conn_id)
                            thread.start()
                            if thread.isAlive():
                                serveingPorts[port, protocol] = thread
                                activePortListRespond["report"][protocol][port] = "OK"
                            else:
                                activePortListRespond["message"] = "NOT OK"
                                activePortListRespond["report"][protocol][port] = "NOT OK"

                if activePortListRespond["message"] == "NOT OK":
                    loggerS.error(f"Didn\'t manage to activate servers on all ports")

                activePortListRespond = json.dumps(activePortListRespond)
                loggerS.debug(f"activePortListRespond for {client_ip} TCP {local_port} was decoded into json string successfully")
                self.request.sendall(bytes(activePortListRespond, encoding='utf-8'))
                loggerS.debug(f"activePortListRespond for {client_ip} TCP {local_port} was sent successfully: {activePortListRespond}")

            except (socket.timeout, ConnectionError):
                loggerS.error(f"Timeout/Connection error with {client_ip} TCP {local_port} while {flag} operation")
                break

            except UnicodeDecodeError:
                loggerS.error(f"{flag} from {client_ip} TCP {local_port} wasn't decoded")
                break

            except json.decoder.JSONDecodeError:
                loggerS.error(f"{flag} {client_ip} TCP {local_port} wasn't decoded json/python")
                break

            except InterruptedError:
                loggerS.error(f"{flag} operation with {client_ip} TCP {local_port} was interrupted")
                break

class portThread(threading.Thread):
    """
    Экземпляр данного класса представляет собой поток, в котором поднимается сокет-сервер на указанном порту
    """
    def __init__(self, port, protocol, connection_id):
        """
        При создании экземпляра класса необходимо передать следующие параметры:

        :param port: порт, на котором необходимо развернуть сокет-сервер
        :param protocol: протокол, на котором будет работать создаваемый сокет-сервер
        :param connection_id: идентификатор иницилизирующий сессию внутри которой происходит проверка данного порта
        """
        self.port = port
        self.protocol = protocol
        self.conn_id = connection_id
        self.server = None
        threading.Thread.__init__(self)
        self.setDaemon(True)
        try:
            if self.protocol == "TCP":
                self.server = myTCPServer((hostAddress, self.port), myPortTCPRequestHandler)
                loggerS.debug(f"{hostAddress} TCP {self.port} SocketServer was created")
                serverPersonalReports[self.conn_id]["report"]["protocol"][self.protocol][self.port] = {"sockServ creation": "OK", "serve_forever": "NOT OK", "recv": "NOT OK", "send": "NOT OK"}
            elif self.protocol == "UDP":
                self.server = myUDPServer((hostAddress, self.port), myPortUDPRequestHandler)
                loggerS.debug(f"{hostAddress} UDP {self.port} SocketServer was created")
                serverPersonalReports[self.conn_id]["report"]["protocol"][self.protocol][self.port] = {"sockServ creation": "OK", "serve_forever": "NOT OK", "recv": "NOT OK", "send": "NOT OK"}
        except:
            loggerS.error(f"Couldn\'t create SocketServer on {hostAddress} {self.protocol} {self.port}")
            serverPersonalReports[self.conn_id]["report"]["protocol"][self.protocol][self.port] = {"sockServ creation": "NOT OK", "serve_forever": "NOT OK", "recv": "NOT OK", "send": "NOT OK"}

    def run(self):
        """
        Метод осуществляющий запуск сокет-сервера
        """
        try:
            serverPersonalReports[self.conn_id]["report"]["protocol"][self.protocol][self.port]["serve_forever"] = "OK"
            self.server.serve_forever()
        except:
            serverPersonalReports[self.conn_id]["report"]["protocol"][self.protocol][self.port]["serve_forever"] = "NOT OK"
            loggerS.error(f"couldn\'t launche serve_forever SocketServer on {hostAddress} {self.protocol} {self.port}")

    def stop_server(self):
        """
        Метод осуществляющий остановку сокет-сервера
        """
        try:
            self.server.shutdown()
            loggerS.debug(f"{hostAddress} {self.protocol} {self.port} server was shutdown")
        except:
            pass
        try:
            self.server.server_close()
            loggerS.debug(f"{hostAddress} {self.protocol} {self.port} socket was closed")
        except:
            pass


class myPortTCPRequestHandler(socketserver.StreamRequestHandler):
    """
    Экземпляром данного класса является handler сокет-сервера, поднятого для проверки серверного порта,
    который выполняет обработку соединений установленных с клиентом через порт работающий по TCP протоколу
    """
    def handle(self):
        """
        Метод обрабатывающий спец. сообщения переданные клиентом и подтверждающий установление соединения
        с клиентом, либо сообщающей об ошибке

        Типы сообщений:
        - simpleRespond - ответ сервера на клиентский запрос simpleRequest, подтверждающий, что клиент получил доступ к данному порту
        """
        client_ip = self.client_address[0]
        local_port = self.request.getsockname()[1]
        try:
            rcv = self.request.recv(4096)
            loggerS.debug(f"Message from {client_ip} TCP {local_port} was received successfully")
            msg = rcv.decode()
            loggerS.debug(f"Message from {client_ip} TCP {local_port} was decoded successfully")
            pyMsg = json.loads(msg)
            loggerS.debug(f"Message from {client_ip} TCP {local_port} was decoded in python object format successfully")
            if pyMsg["type"] == "simpleRequest":
                loggerS.debug(f"simpleRequest from {client_ip} TCP {local_port} was received successfully: {pyMsg}")
                serverPersonalReports[pyMsg["connection id"]]["report"]["protocol"]["TCP"][local_port]["recv"] = "OK"
            else:
                loggerS.error(f"Unknown message from {client_ip} TCP {local_port} was received successfully. Expected simpleRequest")
                return

            flag = "sendall"
            simpleRespond = {
              "type": "simpleRespond",
              "command": "mainCheck",
              "server address": hostAddress,
              "server name": hostName,
              "connection id": pyMsg["connection id"],
              "message": "OK",
              "protocol": "TCP",
              "port": local_port
            }
            simpleRespond = json.dumps(simpleRespond)
            loggerS.debug(f"simpleRespond {client_ip} TCP {local_port} was decoded in json string successfully")
            self.request.sendall(bytes(simpleRespond, encoding='utf-8'))
            serverPersonalReports[pyMsg["connection id"]]["report"]["protocol"]["TCP"][local_port]["send"] = "OK"
            loggerS.debug(f"simpleRespond was sent to {client_ip} TCP {local_port} successfully: {simpleRespond}")
        except UnicodeDecodeError:
            loggerS.error(f"while {flag} operation {client_ip} TCP {local_port} message wasn\'t decoded")
        except json.decoder.JSONDecodeError:
            loggerS.error(f"while {flag} operation {client_ip} TCP {local_port} message wasn\'t decoded in other format")
        except (ConnectionError, InterruptedError):
            loggerS.error(f"while {flag} operation {client_ip} TCP {local_port} connection was lost")


class myPortUDPRequestHandler(socketserver.DatagramRequestHandler):
    """
    Экземпляром данного класса является handler сокет-сервера, поднятого для проверки серверного порта,
    который выполняет обработку сообщений полученных от клиента через порт работающий по UDP протоколу
    """
    def handle(self):
        """
        Метод обрабатывающий спец. сообщения переданные клиентом и подтверждающий доступ
        клиента к серверу по проверяемому порту, либо сообщающий об ошибке

        Типы сообщений:
        - simpleRespond - ответ сервера на клиентский запрос simpleRequest, подтверждающий, что клиент получил доступ к данному порту
        """
        client_ip = self.client_address[0]
        local_port = self.socket.getsockname()[1]
        try:
            flag = "recv"
            rcv = self.request[0]
            loggerS.debug(f"Message from {client_ip} UDP {local_port} was received successfully")
            msg = rcv.decode()
            loggerS.debug(f"Message from {client_ip} UDP {local_port} was decoded successfully")
            socket = self.request[1]
            pyMsg = json.loads(msg)
            loggerS.debug(f"Message from {client_ip} UDP {local_port} was decoded in python object successfully")
            if pyMsg["type"] == "simpleRequest":
                loggerS.debug(f"simpleRequest from {client_ip} UDP {local_port} was received successfully: {pyMsg}")
                conn_id = pyMsg["connection id"]
                serverPersonalReports[conn_id]["report"]["protocol"]["UDP"][local_port]["recv"] = "OK"
            else:
                loggerS.error(f"Unknown message from {client_ip} UDP {local_port} was received successfully. Expected simpleRequest")
                return

            flag = "sendto"
            simpleRespond = {
              "type": "simpleRespond",
              "command": "mainCheck",
              "server address": hostAddress,
              "server name": hostName,
              "connection id": conn_id,
              "message": "OK",
              "protocol": "UDP",
              "port": local_port
            }
            simpleRespond = json.dumps(simpleRespond)
            loggerS.debug(f"simpleRespond for {client_ip} UDP {local_port} was decoded in json string successfully")
            socket.sendto(bytes(simpleRespond, encoding='utf-8'), self.client_address)
            serverPersonalReports[conn_id]["report"]["protocol"]["UDP"][local_port]["send"] = "OK"
            loggerS.debug(f"simpleRespond for {client_ip} UDP {local_port} was sent successfully: {simpleRespond}")
        except UnicodeDecodeError:
            loggerS.error(f"while {flag} operation {client_ip} UDP {local_port} message wasn\'t decoded")
        except json.decoder.JSONDecodeError:
            loggerS.error(f"while {flag} operation {client_ip} UDP {local_port} message wasn\'t decoded in other format")
        except (ConnectionError, InterruptedError):
            loggerS.error(f"while {flag} operation {client_ip} UDP {local_port} connection was lost")


"""
Анализ указанных параметров и атрибутов при запуске сервиса через терминал
и запуск сервиса в указанном режиме
"""
if __name__ == "__main__":
    if len(sys.argv) == 1:
        print("Choose mode server/client")
        exit()
    elif len(sys.argv) == 2:
        if sys.argv[1] == "cl":
            print("Choose file with list of servers")
            exit()
        elif sys.argv[1] == "srv":
            mainThread = mainServerThread(hostAddress, 3242)
            mainThread.start()
            print("TCP socket-server on port 3242 is serving...")
            while True:
                try:
                    if not mainThread.isAlive():
                        print("Server can\'t be launched.\nCheck TCP 3242 port.")
                        break
                    else:
                        time.sleep(60)
                        print(threading.activeCount() - 2, "active socket-servers:")
                        for key, value in serveingPorts.items():
                            if value.isAlive():
                                print(key)

                except KeyboardInterrupt:
                    # for server in serveingPorts.values():
                    #     server.stop_server()
                    #     server.join()
                    mainThread.stop_server()
                    print("Server was stopped")
                    break
            exit()

    elif len(sys.argv) == 3 and sys.argv[1] == "cl":
        serverListFileName = sys.argv[2]
        file_checked = config_check(serverListFileName)
        if file_checked[0] == 0:
            checkList = []
            id_statusDic = str(uuid.uuid4())
            serversStatusDic[id_statusDic] = {"status": "OK"}
            serverPortsStatusDic[id_statusDic] = {"status": "OK"}
            for server in file_checked[1]:
                thread = clientThread(server["ip"], 3242, server["ports"], file_checked[1], id_statusDic, "main")
                checkList.append(thread)
                thread.start()
            for server in checkList:
                if server.isAlive():
                    server.join()
            if serversStatusDic[id_statusDic]["status"] == "OK":
                loggerCl.info(f"All servers are available on TCP 3242: {serversStatusDic[id_statusDic]}")
                print("All servers are available on TCP 3242:", serversStatusDic[id_statusDic])
                if serverPortsStatusDic[id_statusDic]["status"] == "OK":
                    loggerCl.info(f"All ports were activated on servers: {serverPortsStatusDic[id_statusDic]}")
                    print("All ports were activated on servers:", serverPortsStatusDic[id_statusDic])
                    for id in mainClientReports.keys():
                        finalReports[id] = form_report(mainClientReports[id], mainServerReports[id])
                else:
                    loggerCl.warning(f"All ports were activated on servers: {serverPortsStatusDic[id_statusDic]}")
                    print("Not all servers activated ports", serverPortsStatusDic[id_statusDic])
            else:
                loggerCl.warning(f"Not all servers are available on TCP 3242:{serversStatusDic[id_statusDic]}")
                print("Not all servers are available on TCP 3242:", serversStatusDic[id_statusDic])
        else:
            if file_checked[0] == 1:
                print("Problems:", file_checked[1])
            exit()
    else:
        print("Unknown arguments were given")
        exit()

    if serversStatusDic[id_statusDic]["status"] == "OK" and serverPortsStatusDic[id_statusDic]["status"] == "OK":
        mainReport = form_final_report(finalReports, finalServerReports)
        try:
            conn = sqlite3.connect("reports.db")
            cursor = conn.cursor()
            cursor.execute("""CREATE TABLE IF NOT EXISTS Servers
                              (session_id text, client_ip text, server_ip text, server_name text, respond_time text, TCP text, UDP text, status text, ERROR text)""")
            for key1, value1 in mainReport.items():
                if key1 != "problems":
                    if "problem" not in value1.keys():
                        for key2, value2 in value1.items():
                            for key3, value3 in value2["report"].items():
                                if key3 == "TCP":
                                    for key4, value4 in value3.items():
                                        cursor.execute(f"""INSERT INTO Servers
                                                          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)""", [id_statusDic, key1, key2, value2["server name"], value2["respond time"], key4, "-", value4, "-"])
                                        conn.commit()
                                elif key3 == "UDP":
                                    for key4, value4 in value3.items():
                                        cursor.execute(f"""INSERT INTO Servers
                                                          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)""", [id_statusDic, key1, key2, value2["server name"], value2["respond time"], "-", key4, value4, "-"])
                                        conn.commit()
                    else:
                        cursor.execute(f"""INSERT INTO Servers
                                                      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)""", [id_statusDic, key1, "-", "-", "-", "-", "-", "-", value1["problem"]])
                        conn.commit()
        except:
            loggerCl.exception("Didn\'t manage to upload data into DB correctly")
            print("Didn\'t manage to upload data into DB correctly")
        try:
            mainReport = json.dumps(mainReport, indent=4)
            with open("val_Service_report.json", "w") as w_f:
                w_f.write(mainReport)
        except:
            loggerCl.error("Didn\'t manage to write report in json file")
        print("Main report:", mainReport)
    print("Validation was completed")
