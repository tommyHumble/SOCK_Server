
import socketserver
import json
import threading
import time
import socket
import logging
import sys

def get_ip():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(('10.255.255.255', 1))
        IP = s.getsockname()[0]
    except:
        IP = '127.0.0.1'
    finally:
        s.close()
    return IP

# ip клиента/сервера
hostAddress = get_ip()

# Настройка логгера
logger = logging.getLogger("Server_Side")
logger.setLevel(logging.DEBUG)
fileHandler = logging.FileHandler("server_logs.log")
fileFormatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s - %(funcName)s")
fileHandler.setFormatter(fileFormatter)
logger.addHandler(fileHandler)

# запрос на проверку порта 3242 (string)
mainRequest = {
  "type": "mainRequest",
  "command": "mainCheck",
  "message": "PORT 3242 STATUS",
  "client": hostAddress
}
mainRequest = json.dumps(mainRequest)

# Ответ о проверкке порта 3242
mainRespond = {
  "type": "mainRespond",
  "command": "mainCheck",
  "message": "OK",
  "server": hostAddress
}
mainRespond = json.dumps(mainRespond)

# список портов передаваемых от клиента для запуска на стороне сервера
portList = {
  "type": "portList",
  "command": "check",
  "ports": None,
  "client": hostAddress,
}

# Ответ о получении списка проверяемых портов
portListRespond = {
  "type": "portListRespond",
  "command": "mainCheck",
  "message": "OK",
  "server": hostAddress
}
portListRespond = json.dumps(portListRespond)

# Ответ о запуске проверяемых портов
activePortListRespond = {
  "type": "activePortListRespond",
  "command": "mainCheck",
  "message": "OK",
  "server": hostAddress
}
activePortListRespond = json.dumps(activePortListRespond)

# запрос на проверку порта по TCP или UDP
simpleRequest = {
  "type": "request",
  "command": "check",
  "message": "PORT STATUS",
  "client": hostAddress,
  "protocol": None,
  "port": None
}
#simpleRequest = json.dumps(simpleRequest)

# Ответ от проверяемого порта
simpleRespond = {
  "type": "simpleRespond",
  "command": "mainCheck",
  "message": "OK",
  "server": hostAddress,
  "protocol": None,
  "port": None
}
#simpleRespond = json.dumps(simpleRespond)

# Запрос отчета о выполнении полного цикла проверок на сервер
reportRequest = {
  "type": "reportRequest",
  "message": "NEED REPORT",
  "client": hostAddress
}
reportRequest = json.dumps(reportRequest)

# Отчет о выполнении полного цикла проверки на сервере
reportRespond = {
  "type": "reportRespond",
  "message": "REPORT",
  "server": hostAddress,
  "ports": {
    "protocol": {
      "UDP": {},
      "TCP": {}
    }
  }
}
# reportRespond = json.dumps(reportRespond)

# Список экземпляров потоков серверов запущенных на портах {(8080, "UDP"): Thread Obj, ...}  (server)
portThreadDic = {}

# словарь всех серверов, которые клиент должен проверить (достаются из json файла) (client)
serverDic = {}

# Список всех организуемых потоков (столько же, сколько проверяемых серверов) (client)
checkList = []

# Словарь проверенных серверов (адрес хоста и статус порта 3242) (client)
mainCheckDic = {"status": "OK"}

# Отчет со стороны клиента
clientReport = {
  "type": "clientReport",
  "message": "REPORT",
  "client": hostAddress,
  "servers": {
  }
}

def client():
    #global mainCheckDic, checkList
    # Класс - поток. Экземплярами данного класса являются
    # клиентские сокеты, через которые проходит соединение с
    # проверяемыми портами на сервере
    class mySecondaryThread(threading.Thread):
        def __init__(self, host, port, protocol, reqPat):
            self.host = host
            self.port = port
            self.protocol = protocol
            self.reqPat = reqPat
            threading.Thread.__init__(self)
        # при запуске экземпляра данного потока выполнится следующий блок
        # который опросит проверяемые порты на сервере по соотв. протоколу
        # а также получит и выведет ответ от портов
        def run(self):
            if self.protocol == "TCP":
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as prtSock:
                    prtSock.settimeout(1)
                    prtSock.connect((self.host, self.port))
                    mySimpleRequest = self.reqPat.copy()
                    mySimpleRequest["protocol"] = self.protocol
                    mySimpleRequest["port"] = self.port
                    mySimpleRequest = json.dumps(mySimpleRequest)
                    prtSock.sendall(bytes(mySimpleRequest, encoding='utf-8'))
                    rcv = prtSock.recv(1024).decode()
                    print(rcv)
            elif self.protocol == "UDP":
                with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as prtSock:
                    prtSock.settimeout(1)
                    prtSock.connect((self.host, self.port))
                    mySimpleRequest = simpleRequest.copy()
                    mySimpleRequest["protocol"] = self.protocol
                    mySimpleRequest["port"] = self.port
                    mySimpleRequest = json.dumps(mySimpleRequest)
                    prtSock.sendto(bytes(mySimpleRequest, encoding="utf-8"), (self.host, self.port))
                    rcv = prtSock.recv(1024).decode()
                    print(rcv)

    # Класс - поток. Экземплярами данного класса являются
    # клиентские сокеты, через которые проходит соединение с сервером
    # каждый сокет (порт) в отдельном потоке
    class myThread(threading.Thread):
        # передаем ip хоста (клиентской машины)
        # порт на котором хотим организовать сокет
        # и словарь портов, которые сервер должен будет поднять на своей стороне
        def __init__(self, host, port, portCheck, portListPatt):
            self.host = host
            self.port = port
            self.portCheck = portCheck
            self.portListPatt = portListPatt
            threading.Thread.__init__(self)

        # Данная ф-ция описывает, что будет происходить при запуске потока (start())
        def run(self):
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            # создаем сокет
            try:
                sock.settimeout(1)                                              # сокращаем время на установление соединения с сервером
                print("trying to connect", self.host)
                sock.connect((self.host, self.port))                            # Устанавливаем соединение с сервером на порту 3242
                print("connected", self.host)
            except:
                mainCheckDic["status"] = "NOT OK"                               # Если не удалось установить соединение с сервером, то в список мы добавляем блокирующее значение, которое говорит, что можно закругляться
                mainCheckDic[self.host] = "DOWN"
                print(self.host, "HAVA SOME PROBLEMS")
                #sock.close()
                return 0                                                        # Выходим из ф-ции тем самым прерывая поток
            else:
                sock.sendall(bytes(mainRequest, encoding='utf-8'))              # Если соединение установлено, нужно отправить запрос на подтверждение установки соединения
                rcv = sock.recv(1024).decode()                                  # Получаем ответ на запрос, что подверждает, что соединение по 3242 установлено
                mainCheckDic[self.host] = "UP"                       # По получении ответа Добавляем в контрольный список инфу, что на этом хосте порт 3242 работает четко
                print(rcv)

            # проверяем список, всех ли мы опросили и все ли порты доступны
            # если нет, то говорим, что на каком-то порту проблемы и завершаем процесс
            while True:
                if len(mainCheckDic) == len(serverDic)+1:
                    if mainCheckDic["status"] == "NOT OK":
                        print("SOME SERVER IS NOT UP")
                        print(mainCheckDic)
                        return                                                  # Завершаем ф-цию и поток вместе с ней
                    else:
                        print("ALL SERVERS ARE UP")
                        print(mainCheckDic)
                        break

            # формируем список портов, которые сервер должен будет поднять на своей стороне
            portList = self.portListPatt.copy()
            portList["ports"] = self.portCheck
            portList = json.dumps(portList)
            print(portList)
            sock.sendall(bytes(portList, encoding="utf-8"))                     # отправляем список
            recv = sock.recv(1024).decode()                                     # получили подверждение, что список был получен
            print(recv)
            recv = sock.recv(1024).decode()                                     # получили подтверждение того, что все порты подняты и готовы к дальнейшему опросу
            print(recv)

            # получив подтверждение, начинаем опрашивать поочередно наши порты
            # с помощью with открываем соединение, ЗАПРОС - ОТВЕТ, закрываем соединение
            for protocol, ports in self.portCheck.items():
                for port in ports:
                    portThread = mySecondaryThread(self.host, port, protocol, simpleRequest)
                    portThread.start()

            time.sleep(3)
            sock.sendall(bytes(reportRequest, encoding="utf-8"))
            rcv = sock.recv(1024).decode()
            print(rcv)

    # Создаем потоки, в вкоторых будет происходить проверка порта 3242
    # и дальнейшая проверка других портов, если все сервера доступны на 3242
    for srv in serverDic:
        thread = myThread(srv["host"], 3242, srv["ports"], portList)
        checkList.append(thread)
        thread.start()
        print("THREAD GO GO GO GO")

    print(checkList)            # список потоков в которыъ проверяются все сервера = колич-во серверов в json файле

    # Проверка завершения всех вызванных потоков
    for srv in checkList:
        print(srv.getName())
        print(srv.isAlive())
        if srv.isAlive():
            srv.join()
            print('STOPPED')
        else:
            print("ALREADY STOPPED")

    print("FIN")

def server():
    # Handler для обработки соедниений на порту 3242
    class MyTCPRequestHandler(socketserver.StreamRequestHandler):
        def handle(self):
            # Чтобы не разрывать соединение мы будем проверять получаемые сообщение в цикле,
            # выйдем из цикла и разорвем соединение по окончанию работы с клиентом
            logger.debug(f"TCP connection on 3242 with {self.client_address[0]} was established")
            while True:
                try:
                    rcv = self.request.recv(1024)           # получили сообщение
                    if not rcv:
                        logger.debug(f"TCP connection on port 3242 with {self.client_address[0]} was completed")
                        break
                except:
                    logger.warning(f"TCP on port 3242 connection with {self.client_address[0]} was broken while recieving a message")
                    break
                logger.debug(f"message from {self.client_address[0]} was recieved")

                try:
                    msg = rcv.decode()                    # декодировали сообщение из b в str
                    logger.debug(f"message from {self.client_address[0]} was decoded successfuly")
                    pyMsg = json.loads(msg)                 # преобразовали json строку в объект python

                    if pyMsg["type"] == "mainRequest":
                        logger.debug(f"mainRequest message was recieved from {self.client_address[0]}")
                        self.request.sendall(bytes(mainRespond, encoding='utf-8'))
                        logger.debug(f"mainRespond was sent to {self.client_address[0]}")

                    elif pyMsg["type"] == "reportRequest":
                        logger.debug(f"reportRequest message was recieved from {self.client_address[0]}")
                        myReportRespond = json.dumps(reportRespond)
                        self.request.sendall(bytes(myReportRespond, encoding='utf-8'))
                        logger.debug(f"reportRespond was sent to {self.client_address[0]}")

                    elif pyMsg["type"] == "portList":
                        logger.debug(f"portList message was recieved from {self.client_address[0]}")
                        self.request.sendall(bytes(portListRespond, encoding='utf-8'))
                        logger.debug(f"portListRespond was sent to {self.client_address[0]}")

                        # Проходим по словарю портов, которые необходимо поднять для проверки
                        for prt, number in pyMsg["ports"].items():
                            for n in number:
                                # создаем и запускаем сервер на каждом из портов в отедьном потоке, если такого сервера еще нет
                                if (n, prt) in portThreadDic.keys():
                                    logger.debug(f"{prt} server on {n} is already launched")
                                else:
                                    portThread = launchedPort(hostAddress, n, prt)
                                    portThreadDic[n, prt] = portThread
                                    portThread.start()
                                    logger.debug(f"{prt} on port {n} serve_forever is launched")

                        # ОТВЕТ о запуске всех портов (готов к проверке)
                        self.request.sendall(bytes(activePortListRespond, encoding='utf-8')) # нужна ли проверка ?
                        #break

                except UnicodeDecodeError:
                    logger.warning(f"message from {self.client_address[0]} wasn't decoded")
                    break
                except json.decoder.JSONDecodeError:
                    logger.warning(f"message form {self.client_address[0]} wasn't decoded from json format")
                    break
                except InterruptedError:
                    logger.warning(f"failed to send respond to {self.client_address[0]} {pyMsg['type']}")
                    break

    # Класс - поток проверяемого порта. Экземплярами данного класаа являются
    # сервера TCP UDP поднятые на провереяемых портах
    class launchedPort(threading.Thread):
        # передаем ip адресс нашего сервера (на котором заупстим сервер)
        # порт (для которого запустим сервер)
        # протокол транспортного уровня, по которому будет работать сервер (TCP или UDP)
        def __init__(self, host, port, protocol):
            self.host = hostAddress
            self.port = port
            self.protocol = protocol
            threading.Thread.__init__(self)
            self.setDaemon(True)
            try:
                if self.protocol == "TCP":
                    self.server = socketserver.TCPServer((self.host, self.port), mySecondaryTCPRequestHandler)
                    logger.debug(f"{self.host} TCP {self.port} SocketServer was created")
                elif self.protocol == "UDP":
                    self.server = socketserver.UDPServer((self.host, self.port), mySecondaryUDPRequestHandler)
                    logger.debug(f"{self.host} UDP {self.port} SocketServer was created")
            except:
                logger.debug(f"{self.host} {self.protocol} {self.port} SocketServer wasn\'t created")

        # Данная ф-ция описывает действия потока при его запуске (start())
        def run(self):
            try:
                reportRespond["ports"]["protocol"][self.protocol][self.port] = "UP"
                self.server.serve_forever()
            except:
                logger.error(f"{self.protocol} on port {self.port} serve_forever error ")

        def stop_server(self):
            try:
                self.server.shutdown()
                self.server.server_close()
                logger.debug(f"{self.protocol} server on {self.port} port was closed")
            except:
                logger.warning("f{self.protocol} server on {self.port} port couldn\'t be closed correctly")


    class mySecondaryTCPRequestHandler(socketserver.StreamRequestHandler):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            #print('Args:', dir(args[0]))
            #print('Args:', args[0].getsockname())
            #print('kwargs:', kwargs)
            #self.host = self.request.getsockname()[0]
            #self.port = self.request.getsockname()[1]

        def handle(self):
            try:
                rcv = self.request.recv(1024)
                logger.debug(f"simpleRequest from {self.client_address[0]} was recieved on TCP {self.request.getsockname()[1]}")
                msg = rcv.decode()
                logger.debug(f"simpleRequest from {self.client_address[0]} was decoded on TCP {self.request.getsockname()[1]}")
                pyMsg = json.loads(msg)
                logger.debug(f"simpleRequest from {self.client_address[0]} was decoded in json format on TCP {self.request.getsockname()[1]}")
                mySimpleRespond = simpleRespond.copy()
                mySimpleRespond["protocol"] = pyMsg["protocol"]
                mySimpleRespond["port"] = pyMsg["port"]
                mySimpleRespond = json.dumps(mySimpleRespond)
                self.request.sendall(bytes(mySimpleRespond, encoding='utf-8'))
                logger.debug(f"simpleRespond was sent to {self.client_address[0]} from TCP {self.request.getsockname()[1]}")
            except UnicodeDecodeError:
                logger.warning(f"simpleRequest from {self.client_address[0]} wasn\'t decoded on TCP {self.request.getsockname()[1]}")
            except json.decoder.JSONDecodeError:
                logger.warning(f"simpleRequest from {self.client_address[0]} wasn\'t decoded from json format on TCP {self.request.getsockname()[1]}")
            except InterruptedError:
                logger.exception(f"failed to send\/recieve message to\/from {self.client_address[0]} on TCP {self.request.getsockname()[1]}")

    class mySecondaryUDPRequestHandler(socketserver.DatagramRequestHandler):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self.host = self.socket.getsockname()[0]
            self.port = self.socket.getsockname()[1]

        def handle(self):
            try:
                rcv = self.request[0]
                logger.debug(f"simpleRequest from {self.client_address[0]} was recieved on UDP {self.socket.getsockname()[1]}")
                msg = rcv.decode()
                logger.debug(f"simpleRequest from {self.client_address[0]} was decoded on UDP {self.socket.getsockname()[1]}")
                socket = self.request[1]
                pyMsg = json.loads(msg)
                mySimpleRespond = simpleRespond.copy()
                mySimpleRespond["protocol"] = pyMsg["protocol"]
                mySimpleRespond["port"] = pyMsg["port"]
                mySimpleRespond = json.dumps(mySimpleRespond)
                socket.sendto(bytes(mySimpleRespond, encoding='utf-8'), self.client_address)
                logger.debug(f"simpleRespond was sent to {self.client_address[0]} from UDP {self.socket.getsockname()[1]}")
            except UnicodeDecodeError:
                logger.warning(f"simpleRequest from {self.client_address[0]} wasn\'t decoded on UDP {self.socket.getsockname()[1]}")
            except json.decoder.JSONDecodeError:
                logger.warning(f"simpleRequest from {self.client_address[0]} wasn\'t decoded from json format on UDP {self.socket.getsockname()[1]}")
            except InterruptedError:
                logger.exception(f"failed to send\/recieve message to\/from {self.client_address[0]} on UDP {self.socket.getsockname()[1]}")

    class main_thread(threading.Thread):
        def __init__(self, addr, port):
            self.addr = addr
            self.port = port
            threading.Thread.__init__(self)
            try:
                self.server = socketserver.TCPServer((self.addr, port), MyTCPRequestHandler)
                logger.debug(f"{self.addr} 'TCP' {self.port} SocketServer was created")
            except:
                logger.warning(f"{self.addr} 'TCP' {self.port} SocketServer wasn\'t created")
        def run(self):
            try:
                self.server.serve_forever()
            except:
                logger.error(f"SocketServer on port {self.port} serve_forever error ")
        def stop_server(self):
            try:
                self.server.shutdown()
                self.server.server_close()
                logger.debug(f"SocketServer on {self.port} port was closed")
            except:
                logger.warning(f"SocketServer on {self.port} port couldn\'t be closed correctly")

    mainThread = main_thread(hostAddress, 3242)
    mainThread.start()

    while True:
        try:
            print(threading.activeCount(), "ACTIVE THREADS")
            print(portThreadDic)
            time.sleep(60)
            #print(serverDic)
        except KeyboardInterrupt:
            mainThread.stop_server()
            break

        # for i in serverDic.values():
        #     i.shutdown()
        #     i.server_close()                # вызывается для очистки сервера (сокета, если конкретнее) (self.socket.close())
        #     print("DOOOWN B**CH")
        # serverDic = {}
        # print("I\'M CLEAN AND READY FOR WORK")

# Считывание json файла со списком серверов
# запускаем приложение в 1-ом из режимов
if sys.argv[1] == 'client':
    serverListFileName = sys.argv[2]
    with open(serverListFileName, 'r') as f_r:
        serverDic = json.load(f_r)
    client()
elif sys.argv[1] == 'server':
    server()
