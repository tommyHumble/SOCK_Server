import socketserver, json, threading, time, socket, sys

# имя клиента/сервера
hostName = socket.gethostname()
# ip клиента/сервера
hostAddress = socket.gethostbyname(hostName)
print(hostAddress)

# запрос на проверку порта 3242 (string)
mainRequest = {
  "type": "mainRequest",
  "command": "mainCheck",
  "message": "PORT 3242 STATUS",
  "client": hostAddress
}
mainRequest = json.dumps(mainRequest)

# Ответ о проверкке порта 3242
mainRespond = {
  "type": "mainRespond",
  "command": "mainCheck",
  "message": "OK",
  "server": hostAddress
}
mainRespond = json.dumps(mainRespond)

# список портов передаваемых от клиента для запуска на стороне сервера
portList = {
  "type": "portList",
  "command": "check",
  "ports": None,
  "client": hostAddress,
}

# Ответ о получении списка проверяемых портов
portListRespond = """{
  "type": "portListRespond",
  "command": "mainCheck",
  "message": "OK"
}"""

# Ответ о запуске проверяемых портов
activePortListRespond = """{
  "type": "activePortListRespond",
  "command": "mainCheck",
  "message": "OK"
}"""

# запрос на проверку порта по TCP или UDP
simpleRequest = {
  "type": "request",
  "command": "check",
  "message": "PORT STATUS",
  "client": hostAddress,
  "protocol": None,
  "port": None
}
#simpleRequest = json.dumps(simpleRequest)

# Ответ от проверяемого порта
simpleRespond = {
  "type": "simpleRespond",
  "command": "mainCheck",
  "message": "OK",
  "server": hostAddress,
  "protocol": None,
  "port": None
}
simpleRespond = json.dumps(simpleRespond)

# Запрос отчета о выполнении полного цикла проверок на сервер
reportRequest = {
  "type": "reportRequest",
  "message": "NEED REPORT",
  "client": hostAddress
}
reportRequest = json.dumps(reportRequest)

# Отчет о выполнении полного цикла проверки на сервере
reportRespond = {
    "type": "reportRespond",
    "3242 status": "",
    "ports": None,
    "server": hostAddress
}
reportRespond = json.dumps(reportRespond)

# Сервера проверяемых портов (server)
portServerDic = {}

# Список всех организуемых потоков (столько же, сколько проверяемых серверов) (client)
checkList = []

# Словарь проверяемых серверов (адрес хоста и статус порта 3242) (client)
mainCheckList = []

def client():
    global mainCheckList, checkList

    # Класс - поток. Экземплярами данного класса являются
    # клиентские сокеты, через которые проходит соединение с
    # проверяемыми портами на сервере
    class mySecondaryThread(threading.Thread):

        def __init__(self, host, port, protocol):
            self.host = host
            self.port = port
            self.protocol = protocol
            threading.Thread.__init__(self)
        # при запуске экземпляра данного потока выполнится следующий блок
        # который опросит проверяемые порты на сервере по соотв. протоколу
        # а также получит и выведет ответ от портов
        def run(self):
            global simpleRequest
            if self.protocol == "TCP":
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as prtSock:
                    prtSock.settimeout(1)
                    prtSock.connect((self.host, self.port))
                    mySimpleRequest = simpleRequest.copy()
                    mySimpleRequest["protocol"] = self.protocol
                    mySimpleRequest["port"] = self.port
                    mySimpleRequest = json.dumps(mySimpleRequest)
                    prtSock.sendall(bytes(mySimpleRequest, encoding='utf-8'))
                    rcv = prtSock.recv(1024).decode()
                    print(rcv)
            elif self.protocol == "UDP":
                with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as prtSock:
                    prtSock.settimeout(1)
                    prtSock.connect((self.host, self.port))
                    mySimpleRequest = simpleRequest.copy()
                    mySimpleRequest["protocol"] = self.protocol
                    mySimpleRequest["port"] = self.port
                    mySimpleRequest = json.dumps(mySimpleRequest)
                    prtSock.sendto(bytes(mySimpleRequest, encoding="utf-8"), (self.host, self.port))
                    rcv = prtSock.recv(1024).decode()
                    print(rcv)

    # Класс - поток. Экземплярами данного класса являются
    # клиентские сокеты, через которые проходит соединение с сервером
    # каждый сокет (порт) в отдельном потоке
    class myThread(threading.Thread):
        # передаем ip хоста (клиентской машины)
        # порт на котором хотим организовать сокет
        # и словарь портов, которые сервер должен будет поднять на своей стороне
        def __init__(self, host, port, portCheck):
            self.host = host
            self.port = port
            self.portCheck = portCheck
            threading.Thread.__init__(self)

        # Данная ф-ция описывает, что будет происходить при запуске потока (start())
        def run(self):
            global portList
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            # создаем сокет
            try:
                sock.settimeout(1)                                              # сокращаем время на установление соединения с сервером
                print("trying to connect", self.host)
                sock.connect((self.host, self.port))                            # Устанавливаем соединение с сервером на порту 3242
                print("connected", self.host)
            except:
                mainCheckList.append('KEK')                                     # Если не удалось установить соединение с сервером, то в список мы добавляем блокирующее значение, которое говорит, что можно закругляться
                print(self.host, "HAVA SOME PROBLEMS")
                #sock.close()
                return 0                                                        # Выходим из ф-ции тем самым прерывая поток
            else:
                sock.sendall(bytes(mainRequest, encoding='utf-8'))              # Если соединение установлено, нужно отправить запрос на подтверждение установки соединения
                rcv = sock.recv(1024).decode()                                  # Получаем ответ на запрос, что подверждает, что соединение по 3242 установлено
                mainCheckList.append([self.host, "UP"])                         # По получении ответа Добавляем в контрольный список инфу, что на этом хосте порт 3242 работает четко
                print(rcv)

            # проверяем список, всех ли мы опросили и все ли порты доступны
            # если нет, то говорим, что на каком-то порту проблемы и завершаем процесс
            while True:
                if len(mainCheckList) == len(serverDic):
                    if "KEK" in mainCheckList:
                        print("SOME SERVER IS NOT UP")
                        return                                                  # Завершаем ф-цию и поток вместе с ней
                    else:
                        print("ALL SERVERS ARE UP")
                        break

            # формируем список портов, которые сервер должен будет поднять на своей стороне
            portList = portList.copy()
            portList["ports"] = self.portCheck
            portList = json.dumps(portList)
            print(portList)
            sock.sendall(bytes(portList, encoding="utf-8"))                     # отправляем список
            recv = sock.recv(1024).decode()                                     # получили подверждение, что список был получен
            print(recv)
            recv = sock.recv(1024).decode()                                     # получили подтверждение того, что все порты подняты и готовы к дальнейшему опросу
            print(recv)

            # получив подтверждение, начинаем опрашивать поочередно наши порты
            # с помощью with открываем соединение, ЗАПРОС - ОТВЕТ, закрываем соединение
            for protocol, ports in self.portCheck.items():
                for port in ports:
                    portThread = mySecondaryThread(self.host, port, protocol)
                    portThread.start()

            time.sleep(1)
            sock.sendall(bytes(reportRequest, encoding="utf-8"))
            rcv = sock.recv(1024).decode()
            print(rcv)

    # Создаем потоки, в вкоторых будет происходить проверка порта 3242
    # и дальнейшая проверка других портов, если все сервера доступны на 3242
    for srv in serverDic:
        thread = myThread(srv["host"], 3242, srv["ports"])
        checkList.append(thread)
        thread.start()
        print("THREAD GO GO GO GO")

    print(checkList)            # список потоков в которыъ проверяются все сервера = колич-во серверов в json файле
    print(mainCheckList)        # список всех серверов + статус порта 3242 + ключ о дальнейшей проверки

    # Проверка завершения всех вызванных потоков
    for srv in checkList:
        print(srv.getName())
        print(srv.isAlive())
        if srv.isAlive():
            srv.join()
            print('STOPPED')
        else:
            print("ALREADY STOPPED")

    print("FIN")

def server():
    global portServerDic
    # Handler для обработки соедниений на порту 3242
    class MyTCPRequestHandler(socketserver.StreamRequestHandler):
        def handle(self):

            # Чтобы не разрывать соединение мы будем проверять получаемые сообщение в цикле,
            # выйдем из цикла и разорвем соединение по окончанию работы с клиентом
            while True:
                try:
                    msg = self.request.recv(1024)           # получили сообщение
                    c_str = msg.decode()                    # декодировали сообщение из b в str
                    p_f = json.loads(c_str)                 # преобразовали json строку в объект python
                    print(p_f)
                except:
                    pass
                else:
                    # Проверка типа полученного запроса
                    # ЗАПРОС - ОТВЕТ о проверке порта 3242
                    if p_f["type"] == "mainRequest":
                        self.request.sendall(bytes(mainRespond, encoding='utf-8'))

                    elif p_f["type"] == "reportRequest":
                        self.request.sendall(bytes(reportRespond, encoding='utf-8'))

                    # ЗАПРОС - ОТВЕТ о получении списка проверяемых портов
                    elif p_f["type"] == "portList":
                        self.request.sendall(bytes(portListRespond, encoding='utf-8'))
                        print(p_f["ports"])

                        # Проходим по словарю портов, которые необходимо поднять для проверки
                        for prt, number in p_f["ports"].items():
                            if number != []:
                                for n in number:
                                    # создаем и запускаем сервер на каждом из портов в отедьном потоке
                                    portThread = launchedPort(hostAddress, n, prt)
                                    portThread.start()

                        # ОТВЕТ о запуске всех портов (готов к проверке)
                        self.request.sendall(bytes(activePortListRespond, encoding='utf-8'))
                        break

    # Класс - поток проверяемого порта. Экземплярами данного класаа являются
    # сервера TCP UDP поднятые на провереяемых портах
    class launchedPort(threading.Thread):
        # передаем ip адресс нашего сервера (на котором заупстим сервер)
        # порт (для которого запустим сервер)
        # протокол транспортного уровня, по которому будет работать сервер (TCP или UDP)
        def __init__(self, host, port, protocol):
            self.host = hostAddress
            self.port = port
            self.protocol = protocol
            threading.Thread.__init__(self)
            self.setDaemon(True)

        # Данная ф-ция описывает действия потока при его запуске (start())
        def run(self):
            #global portServerDic                                                # Словарь поднятых TCP UDP серверов для проверяемых портов (чтобы потом их положить)
            if self.protocol == "TCP":
                aServer = socketserver.TCPServer((self.host, self.port), mySecondaryTCPRequestHandler)
                portServerDic[self.protocol, self.port] = aServer
                print("PORT {} IS TCP UP".format(self.port))
                print(portServerDic)
                aServer.serve_forever()
            elif self.protocol == "UDP":
                aServer = socketserver.UDPServer((self.host, self.port), mySecondaryUDPRequestHandler)
                portServerDic[self.protocol, self.port] = aServer
                print("PORT {} IS UDP UP".format(self.port))
                print(portServerDic)
                aServer.serve_forever()

    class mySecondaryTCPRequestHandler(socketserver.StreamRequestHandler):
        def handle(self):
            msg = self.request.recv(1024)
            c_str = msg.decode()
            p_f = json.loads(c_str)
            print(p_f, "TCP")
            self.request.sendall(bytes(simpleRespond, encoding='utf-8'))

    class mySecondaryUDPRequestHandler(socketserver.DatagramRequestHandler):
        def handle(self):
            msg = self.request[0].decode()
            socket = self.request[1]
            msg = json.loads(msg)
            print(msg, "UDP")
            socket.sendto(bytes(simpleRespond, encoding='utf-8'), self.client_address)

    def my_server1():
        aServer = socketserver.TCPServer((hostAddress, 8888), MyTCPRequestHandler)
        aServer.serve_forever()

    t1 = threading.Thread(target=my_server1)
    t1.start()
    print('SERVER IS LAUNCHED')

    while True:
        #global portServerDic
        time.sleep(5)
        print(threading.activeCount(), "ACTIVE THREADS")
        print(portServerDic)
        for i in portServerDic.values():
            i.shutdown()
            i.server_close()                # вызывается для очистки сервера (сокета, если конкретнее) (self.socket.close())
            print("DOOOWN B**CH")
        portServerDic = {}
        print("I\'M CLEAN AND READY FOR WORK")


# Считывание json файла со списком серверов
# запускаем приложение в 1-ом из режимов
if sys.argv[1] == 'client':
    serverListFileName = sys.argv[2]
    with open(serverListFileName, 'r') as f_r:
        serverDic = json.load(f_r)
    client()
elif sys.argv[1] == 'server':
    server()
